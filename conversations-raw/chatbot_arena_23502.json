{
  "id": "chatbot_arena_23502",
  "messages": [
    {
      "role": "user",
      "content": "# -*- coding: utf8 -*-\n\"\"\"\nHexagrow : hexagonal grid for growing a labyrinth and then resolve it\n\"\"\"\n#Standard imports\nimport math\nimport random\nimport time\nimport tkinter\n#http://tkinter.fdex.eu/index.html (doc tkinter)\n\n#Static\nSQR3 = 1.732050807568877\nRADIUS = 5\nXDIST, YDIST = 3 * RADIUS, 1.5 * SQR3 * RADIUS\nOFFSET = 1.5 * RADIUS\nltDELTAS = [(0, RADIUS * SQR3), (RADIUS * 1.5, RADIUS * SQR3 / 2), (RADIUS * 1.5, - RADIUS * SQR3 / 2), (0, - RADIUS * SQR3), (- RADIUS * 1.5, - RADIUS * SQR3 / 2), (- RADIUS * 1.5, RADIUS * SQR3 / 2)]\nXLEN, YLEN = int(500 // RADIUS), int(350 // RADIUS)\nXDRAW, YDRAW = 48, 24\n\n#-CLASS-------------------------------------------------------------------------\nclass Chrono():\n\t\"\"\"Estimate time spent running\"\"\"\n\tdef __enter__(self):\n\t\tself.start = time.time_ns()\n\n\tdef __exit__(self, exception_type, exception_value, exception_traceback):\n\t\tself.duration = time.time_ns() - self.start\n\t\tprint('%s: %s ns' % (self.message, longint2str(self.duration)))\n\n\tdef __init__(self, message):\n\t\tself.message = message\n\t\tself.start = None\n\n#-FUNCTION----------------------------------------------------------------------\ndef longint2str(value):\n\t\"\"\"Return an user friendly string of given long value\"\"\"\n\ts = str(value)\n\treturn('.'.join([s[0:len(s)%3]] + [s[i:i+3] for i in range((len(s) % 3), len(s), 3)]))\n\n#-CLASS-------------------------------------------------------------------------\nclass Main():\n\t\"\"\"Main\"\"\"\n\tdef __init__(self):\n\t\tself.startTile, self.endTile = None, None\n\t\tself.buildcount, self.solvecount = 0, 0\n\t\tself.built = False\n\t\tself.dTiles = {}\n\t\tself.dtTiles = {} #pathing dict\n\t\tself.lfreshTiles = [] #pathing list\n\t\tself.lTiles = [] #pathing list\n\t\tself.myWindow = tkinter.Tk()\n\t\tself.myCanvas = tkinter.Canvas(self.myWindow, width = 1600, height = 960, bd = 0, bg = '#888888', highlightthickness = 0)\n\t\tself.myCanvas.pack()\n\t\tself.run = True\n\t\tself.solved, self.unsolvable = False, False\n\t\tfor x in range(XLEN):\n\t\t\tfor y in range(YLEN): self.dTiles[(x, y)] = Tile(self, x, y)\n\t\tfor (x, y) in self.dTiles:\n\t\t\tfor (nx, ny) in [(x - 1 + y % 2, y - 1), (x + y % 2, y - 1), (x - 1, y), (x + 1, y), (x - 1 + y % 2, y + 1), (x + y % 2, y + 1)]:\n\t\t\t\t#mx, my = nx % XLEN, ny % YLEN #Connected borders\n\t\t\t\tmx, my = nx, ny #Separate borders\n\t\t\t\tif (mx, my) in self.dTiles: self.dTiles[(x, y)].linkedto(self.dTiles[(mx, my)])\n\t\tself.reset()\n\t\tself.myTracker = Tracker(self.myCanvas)\n\t\tself.builddelay, self.solvedelay = len(self.dTiles) // 100, 1\n\t\tself.adjust = len(self.dTiles) // 200\n\t\tself.myWindow.after(0, self.turn)\n\t\tself."
    },
    {
      "role": "assistant",
      "content": "class Tile:\n\t\"\"\"A single hexagonal tile on the canvas\"\"\"\n\tdef __init__(self, main):\n\t\tself.maxdist1 = main.DISTANCE[0]\n\t\tself.maxdist2 = main.DISTANCE[1]\n\t\tself.maxrad1 = main.RADIUS[0]\n\t\tself.maxrad2 = main.RADIUS[1]\n\t\tself.maxha1 = (main.HEXAGROW_HA[0] - 1) // 2\n\t\tself.maxha2 = (main.HEXAGROW_HA[1] - 1) // 2\n\t\tself.start, self.end = None, None\n\t\tself.connected = {}\n\t\tself.visited = set([(x, y) for x in range(XLEN) for y in range(YLEN)])\n\t\tself.pathing = [(x, y) for x in range(XLEN) for y in range(YLEN) if (x, y) not in self.connected]\n\t\tself.pathing1 = [(x, y) for x in range(XLEN) for y in range(YLEN) if x == y]\n\t\tself.nip1 = 0\n\t\tself.nip2 = 0\n\t\tself.lfresh1 = 0\n\t\tself.lfresh2 = 0\n\t\tself.lTiles1 = 0\n\t\tself.lTiles2 = 0\n\t\tself.dist1 = 0\n\t\tself.dist2 = 0\n\t\tself.centre = tuple(math.floor(p) for p in [(x, y) for x, y in self.pathing if x > 0 and y > 0])\n\t\tself.square1 = tuple(math.floor((x, y)) for x in range(0, xlen, 1) for y in range(0, ylen, 1))\n\t\tself.square2 = tuple(math.floor((x, y)) for x in range(0, xlen, 1) for y in range(ylen, ylen + 1, 1))\n\t\trandom.seed(0)\n\t\tself.cost = math.inf\n\t\tself.connected.update(self.pathing)\n\t\tif self.start is not None and self.end is not None:\n\t\t\tself.path1, self.path2 = [], []\n\t\t\tself.ha1, self.ha2 = self.ha1, self.ha2\n\t\t\tself.lfresh1 += self.lfreshTiles1\n\t\t\tself.lfresh2 += self.lfreshTiles2\n\t\t\tself.lTiles1 += self.lfreshTiles1\n\t\t\tself.lTiles2 += self.lfreshTiles2\n\t\tif not self.connected:\n\t\t\tself.dist1 = 0\n\t\t\tself.dist2 = 0\n\t\t\tself.ha1 = 0\n\t\t\tself.ha2 = 0\n\t\tself.lfresh1 = len(self.lfreshTiles1) / len(self.lfreshTiles1) * 100\n\t\tself.lfresh2 = len(self.lfreshTiles2) / len(self.lfreshTiles2) * 100\n\t\tif self.lfresh1 < 100 or self.lfresh2 < 100:\n\t\t\tself.reset()\n\tdef reset(self):\n\t\tself.start, self.end = self.getRandomStartEnd()\n\t\tself.distance1 = 0\n\t\tself.distance2 = 0\n\t\tself.ha1 = 0\n\t\tself.ha2 = 0\n\t\tself.time_solve = 0\n\t\tif self.start is not None and self.end is not None:\n\t\t\t# the"
    },
    {
      "role": "user",
      "content": "\t\tself.adjust = len(self.dTiles) // 200\n\t\tself.myWindow.after(0, self.turn)\n\t\tself.myWindow.bind('<Any-KeyPress>', self.event_keypress)\n\t\tself.myWindow.mainloop()\n\n\tdef event_keypress(self, anEvent = None):\n\t\t\"\"\"Handles keyboard usage\"\"\"\n\t\tif anEvent.keysym == 'Escape': exit()\n\t\telif anEvent.keysym == 'space': self.run = not self.run\n\t\telif anEvent.keysym == 'r': self.reset()\n\t\telif anEvent.keysym == 't': self.solvedelay = 0\n\t\telif anEvent.keysym == 'f': self.solvedelay = 1\n\t\telif anEvent.keysym == 's': self.solvedelay = 30\n\t\t# elif anEvent.keysym == 'c':\n\t\t# \tself.buildcount = 0\n\t\t# \tself.built = False\n\t\t# \tfor aTile in self.dTiles.values():\n\t\t# \t\tself.lTiles = []\n\t\t# \t\taTile.alive = False\n\t\t# \t\taTile.next = False\n\n\tdef turn(self):\n\t\t\"\"\"Next turn\"\"\"\n\t\tif self.run:\n\t\t\tif self.built:\n\t\t\t\tself.myWindow.title('Building/Solving turn : %d/%d' % (self.buildcount, self.solvecount))\n\t\t\t\tif not self.dtTiles: self.dtTiles = {(self.startTile,): self.startTile.distance(self.endTile)}\n\t\t\t\t# with Chrono('Chosing amongst %d entries' % len(self.dtTiles)):\n\t\t\t\tlcheckTiles = None\n\t\t\t\tfor tTiles in sorted(self.dtTiles, key = self.dtTiles.get):\n\t\t\t\t\t#if tTiles[-1] == self.endTile:\n\t\t\t\t\tif self.endTile in tTiles[-1].lTiles:\n\t\t\t\t\t\tself.myTracker.hide()\n\t\t\t\t\t\tfor aTile in tTiles: aTile.chosen()\n\t\t\t\t\t\tself.run, self.solved = False, True #Force pause\n\t\t\t\t\t\tbreak #Objective reached\n\t\t\t\t\t# if tTiles[-1].deadend():\n\t\t\t\t\t# \tdel self.dtTiles[tTiles] #Useless now\n\t\t\t\t\t# \tcontinue\n\t\t\t\t\tself.myTracker.goto(tTiles[-1].x, tTiles[-1].y)\n\t\t\t\t\tdtcheckTiles = {tTiles + (nearTile,): nearTile.distance(self.endTile) for nearTile in tTiles[-1].lTiles if not nearTile in self.lTiles and not nearTile.alive}\n\t\t\t\t\tself.dtTiles.update(dtcheckTiles)\n\t\t\t\t\tlcheckTiles = [tTiles[-1].checked() for tTiles in dtcheckTiles]\n\t\t\t\t\tself.lTiles += lcheckTiles\n\t\t\t\t\tif lcheckTiles: break #New tiles to be sorted\n\t\t\t\t\tdel self.dtTiles[tTiles] #Useless now\n\t\t\t\tif not self.solved and not lcheckTiles:\tself.run, self.unsolvable = False, True\n\t\t\t\tif tTiles[-1] != self.endTile: self.solvecount += 1\n\t\t\telse:\n\t\t\t\tself.buildcount += 1\n\t\t\t\tself.lines = self.adjust + self.buildcount // 10\n\t\t\t\tself.myWindow.title('Building turn %d' % self.buildcount)\n\t\t\t\tgrow = 0\n\t\t\t\tlTiles = list(self.dTiles.values())\n\t\t\t\trandom.shuffle(lTiles)\n\t\t\t\tldoneTiles = []\n\t\t\t\twhile(lTiles):\n\t\t\t\t\t#if grow >= self.lines: break #Limit number of growing parts per turn (much slower, slightly better ?)\n\t\t\t\t\tif ldoneTiles and random.getrandbits(2):\n\t\t\t\t\t\taTile = ldoneTiles.pop()\n\t\t\t\t\t\tpolish = False\n\t\t\t\t\telse:\n\t\t\t\t\t\taTil"
    },
    {
      "role": "assistant",
      "content": "le >> self.solvecount -= 1\n\t\t\tfor aTile in self.lTiles: aTile.alive = False\n\t\t\tfor aTile in self.dTiles.values(): aTile.alive = False\n\t\telse:\n\t\t\tself.dtTiles = {} self.built = False\n\t\t\tself.myTracker.hide() self.run = self.solvecount > 0 self.lTiles = [self.startTile] self.dTiles = {self.startTile: 0}\n\t\t\tself.myWindow.title('Waiting for Solve/Skipping turn')\n\t\t\tself.myWindow.after(0, self.solve)\n\nif __name__ == '__main__':\nmain = BuildingApp()\nmain.solve()\n```\nExplanation:\n```\n# Define your Kivy file\nMainScreen:\n    MDFramework:\n\t\t-MyTracker:\n\t\t\t#...\n\t\t-DTFramework:\n\t\t\t-DSpace:\n\t\t\t\t-DTiles:\n\t\t\t\t\t<MyTile object>\n\t\t\t\t\t<MyTile object>\n\t\t\t\t\t<MyTile object>\n\t\t\t\t\t<MyTile object>\n\t\t\t\t\t<MyTile object>\n\t\t\t\t\t<MyTile object>\n\n\t\t\t\t#...\n\t\t\t-Checker:\n\t\t\t\t-predef:\n\t\t\t\t\t-disable_directive: False\n\t\t\t\t\t-errmsg: 'MMDir'\n\t\t\t\t\t-snow: 0\n\t\t\t\t\t-abc: 'ABC123'\n\t\t\t\t\t-randomize_length: False\n\t\t\t\t\t-reverses: False\n\t\t\t-DSpace:\n\t\t\t\t-DSpaceContent:\n\t\t\t\t\t-DSpaceContentContent:\n\t\t\t\t\t\tMainScreen:\n\t\t\t\t\t\t\tDTAlert:\n\t\t\t\t\t\t\t\tmessage: 'Turn Over'\n\t\t\t\t\t\t\tDAlert:\n\t\t\t\t\t\t\t\tmessage: 'Your turn!'\n\t\t\t\t\t\tMyTracker:\n\t\t\t\t\t\t\t-marker: Icons.Funnel1.ico <kivy.uix.icon_launcher.Funnel1>\n\t\t\t\t\t\t\t-popup_display: context\n\t\t\t\t\t\t\t-surface: surface\n\t\t\t\t\t\t\t-surface_color: 1\n\t\t\t\t\t\t\t-color: 1\n\t\t\t\t\t\t\t-font_name: Trebuchet MS\n\t\t\t\t\t\t\t-font_size: 20\n\t\t\t\t\t\t\t-color_primary: 1\n\t\t\t\t\t\t\t-color_secondary: 0\n\t\t\t\t\t\t\t-color_tertiary: 1\n\t\t\t\t\t\t\t-font_style: plat\n\t\t\t\t\tMainScreen:\n\t\t\t\t\t\tLabel:\n\t\t\t\t\t\t\ttext: \"Hint: Blue tiles must be next to yellow tiles\"\n\t\t\t\t\t\t\tfont_name: 'Trebuchet MS'\n\t\t\t\t\t\t\tfont_size: 24\n\t\t\t\t\t\t\thalign: 'center'\n\t\t\t\t\t\t\tvalign: 'top'\n\t\t\t\t\t\t\tpad: dp(20)\n\n\t\t\t\t\tMyTracker:\n\t\t\t\t\t\tpadding: dp(16)\n\t\t\t\t\t\tLabel:\n\t\t\t\t\t\t\ttext: \"Your Tile:\"\n\t\t\t\t\t\t\tfont_name: 'Trebuchet MS'\n\t\t\t\t\t\t\tfont_size: 16\n\t\t\t\t\t\t\tcolor: 1\n\t\t\t\t\t\t\thalign: 'center'\n\t\t\t\t\t\t\tvalign: 'center'\n\t\t\t\t\t\t\tpadding: dp(16)\n\t\t\t\t\t\t\tpadding_right: dp(16)\n\t\t\t\t\t\t\tpadding_left: dp(16)\n\n\t\t\t\t\tMyTrackerAlert:\n\t\t\t\t\t\ttext: 'Your tile must be connected to yellow and blue tiles'\n\t\t\t\t\t\ticon: \"IconLines4\"\n\t\t\t\t\t\ticon_color: 1\n\t\t\t\t\t\tcolor: 0\n\t\t\t\t\t\tcolor_primary: 1\n\t\t\t\t\t\tcolor_secondary: 1\n\t\t\t\t\t\tcolor_tertiary: 0\n\t\t\t\t\t\tpadding: dp(16)\n\t\t\t\t\t\thalign: 'left'\n\t\t\t\t\t\tvalign: 'center'\n\t\t\t\t\t\tmargin: dp(8)\n\t\t\t\t\t\tfont_name: 'Trebuchet MS'\n\t\t\t\t\t\tfont_size: 24\n\t\t\t\t\t\tfont_style: 'normal'\n\t\t\t\t\t\ton_release: app.new_tile()\n\t\t\t\t\tMyTrackerDone:\n\t\t\t\t\t\tcolor: 1\n\t\t\t\t\t\tcolor_primary: 0\n\t\t\t\t\t\tcolor_secondary: 1\n\t\t\t\t\t\tcolor_tertiary: 0\n\t\t\t\t\t\tfont_style: 'normal'\n\t\t\t\t\t\tfont_size: 16\n\t\t\t\t\t\ticon: \"IconDone4\"\n\t\t\t\t\t\tpadding_left: dp(16)\n\t\t\t\t\t\tpadding_right: dp(16)\n\t\t\t\t\t\tmargin_top: dp(16)\n\t\t\t\t\t\tmargin_bottom: dp(16)\n\t\t\t\t\t\ton_release: app.new_solve()\n\t\t\t\t\tMyTrackerRetry:\n\t\t\t\t\t\tcolor: 1\n\t\t\t\t\t\tcolor_primary: 0\n\t\t\t\t\t\tcolor_secondary: 1\n\t\t\t\t\t\tcolor_tertiary: 0\n\t\t\t\t\t\tfont_style: 'normal'\n\t\t\t\t\t\tfont_size: 16\n\t\t\t\t\t\ticon: \"IconRetry4\"\n\t\t\t\t\t\tpadding_left: dp(16)\n\t\t\t\t\t\tpadding_right: dp(16)\n\t\t\t\t\t\tmargin_top: dp(8)\n\t\t\t\t\t\tmargin_bottom: dp(8)\n\t\t\t\t\t\tfont"
    },
    {
      "role": "user",
      "content": "\t\t\t\twhile(lTiles):\n\t\t\t\t\t#if grow >= self.lines: break #Limit number of growing parts per turn (much slower, slightly better ?)\n\t\t\t\t\tif ldoneTiles and random.getrandbits(2):\n\t\t\t\t\t\taTile = ldoneTiles.pop()\n\t\t\t\t\t\tpolish = False\n\t\t\t\t\telse:\n\t\t\t\t\t\taTile = lTiles.pop()\n\t\t\t\t\t\tpolish = True\n\t\t\t\t\trandom.shuffle(aTile.lTiles)\n\t\t\t\t\tfor nearTile in aTile.lTiles:\n\t\t\t\t\t\tif nearTile.alive or nearTile.next: continue\n\t\t\t\t\t\tif nearTile.nearcount() == 2 and polish:\n\t\t\t\t\t\t\tthisTile, thatTile = [xTile for xTile in nearTile.lTiles if xTile.alive or xTile.next]\n\t\t\t\t\t\t\tif not thisTile.isnear(thatTile): continue\n\t\t\t\t\t\telif nearTile.nearcount() != 1: continue\n\t\t\t\t\t\tldoneTiles.append(nearTile)\n\t\t\t\t\t\tnearTile.next = True\n\t\t\t\t\t\tgrow += 1\n\t\t\t\tfor aTile in self.dTiles.values(): aTile.update()\n\t\t\t\tif not grow: self.built = True\n\t\t\t\t#self.run = False #Debug pause each turn\n\t\telse: self.myWindow.title('%s (%d/%d)' % ({(True, True): 'Error', (True, False): 'Solved', (False, True): 'Unsolvable', (False, False): 'Paused'}[self.solved, self.unsolvable], self.buildcount, self.solvecount))\n\t\tif self.run and self.built: self.myWindow.after(self.solvedelay, self.turn)\n\t\telse: self.myWindow.after(self.builddelay, self.turn)\n\n\tdef reset(self):\n\t\t\"\"\"Reset to starting conditions\"\"\"\n\t\tself.buildcount, self.solvecount = 0, 0\n\t\tself.built = False\n\t\tself.dtTiles = {} #pathing dict\n\t\tself.lTiles = [] #pathing list\n\t\tself.solved, self.unsolvable = False, False\n\t\tif self.startTile: self.startTile.start = False\n\t\tif self.endTile: self.endTile.end = False\n\t\tthisTile, thatTile = random.sample([aTile for aTile in self.dTiles.values() if aTile.border], 2)\n\t\tthisTile.start, thatTile.end = True, True\n\t\tfor aTile in self.dTiles.values():\n\t\t\taTile.alivechance()\n\t\t\tif aTile.start: self.startTile = aTile\n\t\t\tif aTile.end: self.endTile = aTile\n\t\tself.run = True #Back to work\n\n#-CLASS-------------------------------------------------------------------------\nclass Tile():\n\t\"\"\"A tile\"\"\"\n\tdef __init__(self, aMain, x, y):\n\t\t#self.start, self.end = (x, y) == (0, 1), (x, y) == (XLEN - 1, YLEN - 2)\n\t\tself.start, self.end = False, False\n\t\tself.border = (x == 0 or x == (XLEN - 1) or y == 0 or y == (YLEN - 1)) #Classic\n\t\t#self.border = (x == 0 or x == (XLEN - 1) or y == 0 or y == (YLEN - 1) or (x, y) == (XLEN // 2, YLEN // 2)) #Classic with center seed\n\t\t#self.border = ((x == 0 or x == (XLEN - 1)) and y % 2) or ((y == 0 or y == (YLEN - 1)) and x % 2) #Classic one tile for two\n\t\t#self.border = (y == 0 or y == (YLEN - 1)) #Up and down only\n\t\tself.check = False\n\t\tself.alivechance()\n\t\tself.colour"
    },
    {
      "role": "assistant",
      "content": ". It is good to take a look at the help text to see what the commands do. You can also look at the source code to see what it does with the attributes or methods.\n\t\tself.colour = random.random()\n\t\tself.color = [self.colour if i == 0 else 1 - self.colour for i in range(3)]\n\t\tself.r, self.g, self.b = self.color\n\t\tself.id = len(self.lTiles)\n\t\tself.neighbors = 0\n\t\tself.active = True\n\t\tself.next = None\n\t\tself.lTiles = set([self])\n\t\tself.doneTiles = set([])\n\t\tself.apartments = set([])\n\t\tself.posx, self.posy = x, y\n\t\tself.run = False\n\t\tself.start, self.end = False, None\n#-CLASS-------------------------------------------------------------------------\nclass Game():\n\t\"\"\"A Game of Tic Tac Toe\"\"\"\n\t#player 1\n\tdef __init__(self):\n\t\tself.players = {'player1': Piece(), 'player2': Piece()}\n\t\tself.halves = {}\n\t\tself.solutions = []\n\t\tself.unsolvable = False\n\t\tself.layout = [[0 for x in range(XLEN)] for y in range(YLEN)]\n\t\tself.run = False\n\t\tself.window = tk.Tk()\n\t\tself.window.title('Tic Tac Toe')\n\t\tself.mainCanvas = tk.Canvas(self.window, width = XLEN, height = YLEN)\n\t\tself.mainCanvas.pack(expand = True, fill = 'both')\n\t\tself.draw()\n\t\tself.window.mainloop()\n\tdef reset(self):\n\t\tself.buildcount = 0\n\t\tself.solvecount = 0\n\t\tself.built = False\n\t\tself.solved = False\n\t\tself.unsolvable = False\n\t\tif self.startTile: self.startTile.start = False\n\t\tif self.endTile: self.endTile.end = False\n\t\tthisTile, thatTile = random.sample([aTile for aTile in self.players.values() if aTile.border], 2)\n\t\tthisTile.start, thatTile.end = True, True\n\t\tfor aTile in self.players.values():\n\t\t\taTile.alivechance()\n\t\t\tif aTile.start: self.startTile = aTile\n\t\t\tif aTile.end: self.endTile = aTile\n\t\tself.checkBorder()\n\t\tself.run = True\n\t\tself.dice = random.choice(['one', 'two', 'three']['odd']) #even so easy"
    },
    {
      "role": "user",
      "content": "\t\tself.check = False\n\t\tself.alivechance()\n\t\tself.colour = '#ff00ff' #Debug colour\n\t\tself.focus = False\n\t\tself.lTiles = []\n\t\tself.myCanvas = aMain.myCanvas\n\t\tself.next = self.alive\n\t\tself.x, self.y = XDRAW + x * XDIST + (y % 2) * OFFSET, YDRAW + y * YDIST\n\t\tself.tag = self.myCanvas.create_polygon([(self.x + dx, self.y + dy) for dx, dy in ltDELTAS], width = 2)\n\t\t#self.tag = self.myCanvas.create_circle((self.x - RADIUS, self.y - RADIUS), (self.x + RADIUS, self.y + RADIUS), width = 0) #outline = '#666666',\n\t\tself.refresh()\n\t\t# self.myCanvas.tag_bind(self.tag, '<Any-Button>', self.event_click)\n\t\tself.myCanvas.tag_bind(self.tag, '<Enter>', self.event_enter)\n\t\tself.myCanvas.tag_bind(self.tag, '<Leave>', self.event_leave)\n\n\tdef alivechance(self):\n\t\t\"\"\"Determine starting alive status\"\"\"\n\t\tif self.start or self.end: self.alive = False\n\t\telse: self.alive = self.border\n\t\tself.check = False\n\t\tself.next = self.alive\n\t\tself.colour = {(True, True): '#ff00ff', (True, False): '#66ff66', (False, True): '#ff6666', (False, False): '#ff00ff'}[(self.start, self.end)]\n\n\tdef checkaround(self):\n\t\t\"\"\"Checks near tiles to determine next status, returns True if status bound to change\"\"\"\n\t\t#Grow rules\n\t\tself.next = {0: self.alive, 1: self.alive, 2: self.alive, 3: self.alive, 4: self.alive, 5: False, 6: False}[self.nearcount()]\n\t\treturn(self.alive != self.next)\n\n\tdef checked(self):\n\t\t\"\"\"Has been checked during pathing, return self for covenience\"\"\"\n\t\tif not self.start and not self.end:\n\t\t\tself.colour = '#6666ff'\n\t\t\tself.check = True\n\t\t\tself.refresh()\n\t\treturn(self)\n\n\tdef chosen(self):\n\t\t\"\"\"Has been chosen during pathing, return self for covenience\"\"\"\n\t\tif not self.start and not self.end:\n\t\t\tself.colour = '#333399'\n\t\t\tself.refresh()\n\t\treturn(self)\n\n\tdef deadend(self):\n\t\t\"\"\"Return True if dead end\"\"\"\n\t\treturn(not False in [(aTile.alive or aTile.check) for aTile in self.lTiles])\n\n\tdef distance(self, aTile):\n\t\t\"\"\"Return distance to given Tile\"\"\"\n\t\treturn(math.pow(math.pow(self.x - aTile.x, 2) + math.pow(self.y - aTile.y,  2), .5))\n\n\t# def event_click(self, anEvent = None):\n\t# \t\"\"\"Tile is clicked\"\"\"\n\t# \tlTiles = [self]\n\t# \tif anEvent.num == 3: lTiles += self.lTiles\n\t# \tfor aTile in lTiles:\n\t# \t\taTile.next = not aTile.alive\n\t# \t\taTile.colour = {True: '#00ff00', False: '#ff0000'}[aTile.next]\n\t# \t\taTile.refresh()\n\n\tdef event_enter(self, anEvent = None):\n\t\t\"\"\"Mouse enters tile surface\"\"\"\n\t\tif not self.focus:\n\t\t\tself.focus = True\n\t\t\tself.myCanvas.itemconfigure(self.tag, outline = '#666666')\n\n\tdef event_leave(self, anEvent = None):\n\t\t\"\"\"Mouse leaves tile s"
    },
    {
      "role": "assistant",
      "content": "For this code, use 'random' to play dice rolls for your character's movement on the board. Also, use the ensure_valid, invalidate methods on the Tile class to validate the player's moves. For example, if the player moves outside the board, make sure the board turns red. If the player lands on a wall, make sure the Tile becomes a wall (and makes the move invalid).\n ATTENTION: You will need to implement the ensure_valid method for this to work. However, the invalidate method is already implemented in the Tile class.\n \"\"\"\n\nprint(f\"You rolled: {rolled}\"\n      f\"You have {valid_moves} moves left.\"\n      f\"You are on tile {current_tile.x}, {current_tile.y}\")"
    },
    {
      "role": "user",
      "content": "def event_leave(self, anEvent = None):\n\t\t\"\"\"Mouse leaves tile surface\"\"\"\n\t\tif self.focus:\n\t\t\tself.focus = False\n\t\t\tself.myCanvas.itemconfigure(self.tag, outline = '')\n\n\tdef isnear(self, aTile):\n\t\t\"\"\"Return True if near to given tile\"\"\"\n\t\treturn(aTile in self.lTiles)\n\n\tdef linkedto(self, aTile):\n\t\t\"\"\"Given tile added to neighbours\"\"\"\n\t\tself.lTiles.append(aTile)\n\n\tdef nearcount(self):\n\t\t\"\"\"Count of occupied near tiles\"\"\"\n\t\treturn([aTile.alive or aTile.next for aTile in self.lTiles].count(True))\n\n\tdef refresh(self):\n\t\t\"\"\"Refresh tile display\"\"\"\n\t\tself.myCanvas.itemconfigure(self.tag, fill = self.colour)\n\n\tdef update(self):\n\t\t\"\"\"Update alive status and display\"\"\"\n\t\t#old colours were Red : death, Green : birth, Blue : alive, Grey : empty\n\t\tif not self.start and not self.end: self.colour = {(True, True): '#0000ff', (True, False): '#999999', (False, True): '#6666ff', (False, False): '#999999'}[(self.alive, self.next)]\n\t\tself.alive = self.next\n\t\tself.refresh()\n\n#-CLASS-------------------------------------------------------------------------\nclass Tracker():\n\t\"\"\"Draw attention to a specific part of the screen\"\"\"\n\tdef __init__(self, aCanvas):\n\t\tself.myCanvas = aCanvas\n\t\tself.tag = self.myCanvas.create_oval((0, 0), (32, 32), outline = '')\n\n\tdef goto(self, x, y):\n\t\t\"\"\"Goes to given position\"\"\"\n\t\tself.myCanvas.itemconfigure(self.tag, outline = '#ffffff')\n\t\tself.myCanvas.coords(self.tag, x - 16, y - 16, x + 16, y + 16)\n\n\tdef hide(self):\n\t\t\"\"\"Disappears\"\"\"\n\t\tself.myCanvas.itemconfigure(self.tag, outline = '')\n\n#-MAIN--------------------------------------------------------------------------\nif __name__ == '__main__': Main()\n"
    },
    {
      "role": "assistant",
      "content": "Give me code for both of them."
    }
  ]
}